{
  "metadata": {
    "version": "1.0",
    "total_points": 64,
    "passing_grade": 40,
    "tech_stack": {
      "frontend": "Next.js",
      "backend": "Express",
      "database": "MongoDB"
    },
    "grading_folder_structure": {
      "frontend": "grading-folder/frontend/",
      "backend": "grading-folder/backend/",
      "documentation": "grading-folder/"
    }
  },
  "criteria": [
    {
      "id": "criterion_1",
      "title": "Project Planning & Problem Definition",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "gpt_semantic",
      "unit_test_weight": 0,
      "gpt_weight": 1.0,
      "test_files": [],
      "files_to_analyze": [
        "grading-folder/README.md",
        "grading-folder/PLANNING.md",
        "grading-folder/docs/**/*"
      ],
      "gpt_instructions": "Evaluate the clarity and depth of problem definition. Assess if the student clearly identifies a real-world problem with thorough analysis of target users and their needs. Check for detailed feature list, user stories, and well-structured wireframes or sitemap. Look for evidence of strong planning skills and structured thinking. Review documentation files for completeness and quality.",
      "levels": {
        "Excellent": "Clearly identifies a real-world problem with thorough analysis of target users and their needs. Includes detailed feature list, user stories, and well-structured wireframes/sitemap demonstrating strong planning skills.",
        "Good": "Identifies a clear problem with good understanding of users. Features are well-defined with basic wireframes. Minor gaps in planning documentation.",
        "Fair": "Problem statement is vague or generic. Feature list exists but lacks detail or prioritization. Wireframes are incomplete or unclear.",
        "Poor": "No clear problem identified or extremely limited planning. Missing wireframes, feature documentation, or evidence of structured thinking."
      }
    },
    {
      "id": "criterion_2",
      "title": "Front-End Implementation (React/Next.js)",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "hybrid",
      "unit_test_weight": 0.7,
      "gpt_weight": 0.3,
      "test_files": [
        "tests/frontend/components.test.js",
        "tests/frontend/hooks.test.js",
        "tests/frontend/routing.test.js"
      ],
      "files_to_analyze": [
        "grading-folder/frontend/components/**/*.tsx",
        "grading-folder/frontend/components/**/*.jsx",
        "grading-folder/frontend/pages/**/*.tsx",
        "grading-folder/frontend/pages/**/*.jsx",
        "grading-folder/frontend/app/**/*.tsx",
        "grading-folder/frontend/app/**/*.jsx"
      ],
      "gpt_instructions": "Assess component architecture quality and organization. Check for proper separation of concerns, component reusability, and clear file structure. Evaluate if components follow React/Next.js best practices. Look for appropriate use of component composition vs. prop drilling. Review state management patterns and whether they're appropriate for the app's complexity. Note any architectural decisions that show advanced understanding or missed opportunities.",
      "levels": {
        "Excellent": "Demonstrates mastery of React/Next.js with proper component architecture, state management (useState, useEffect, useContext/Redux), routing, and component reusability. Code is well-organized with clear separation of concerns.",
        "Good": "Strong React/Next.js implementation with good component structure and state management. Minor issues in organization or missed opportunities for optimization.",
        "Fair": "Basic React/Next.js functionality present but with structural issues. Limited use of hooks, poor component organization, or excessive prop drilling.",
        "Poor": "Minimal React/Next.js implementation. Components are poorly structured, state management is absent or broken, or major functionality is missing."
      }
    },
    {
      "id": "criterion_3",
      "title": "Back-End Architecture (Node.js/Express/NestJS)",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "hybrid",
      "unit_test_weight": 0.7,
      "gpt_weight": 0.3,
      "test_files": [
        "tests/backend/api-endpoints.test.js",
        "tests/backend/middleware.test.js",
        "tests/backend/error-handling.test.js"
      ],
      "files_to_analyze": [
        "grading-folder/backend/routes/**/*.js",
        "grading-folder/backend/controllers/**/*.js",
        "grading-folder/backend/middleware/**/*.js",
        "grading-folder/backend/server.js",
        "grading-folder/backend/app.js"
      ],
      "gpt_instructions": "Evaluate server architecture and organization. Check for RESTful API design principles, proper route organization, and middleware usage. Assess if the code follows MVC or similar architectural patterns. Look for proper separation of concerns between routes, controllers, and business logic. Review error handling implementation and async operation management. Note code organization and maintainability.",
      "levels": {
        "Excellent": "Implements robust server architecture with RESTful API design, proper route organization, middleware usage, error handling, and follows MVC or similar architectural patterns. Demonstrates understanding of async operations.",
        "Good": "Good back-end structure with functional APIs and proper routing. Minor issues in error handling, middleware implementation, or architectural consistency.",
        "Fair": "Basic server functionality with working endpoints but poor organization. Limited error handling, inconsistent API design, or missing middleware.",
        "Poor": "Minimal or broken back-end implementation. APIs are non-functional, poorly structured, or demonstrate fundamental misunderstanding of server-side concepts."
      }
    },
    {
      "id": "criterion_4",
      "title": "Database Design & Integration",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "hybrid",
      "unit_test_weight": 0.6,
      "gpt_weight": 0.4,
      "test_files": [
        "tests/backend/database.test.js",
        "tests/backend/models.test.js",
        "tests/backend/crud-operations.test.js"
      ],
      "files_to_analyze": [
        "grading-folder/backend/models/**/*.js",
        "grading-folder/backend/database/**/*.js",
        "grading-folder/backend/config/db.js"
      ],
      "gpt_instructions": "Assess database schema design quality. Check for proper data modeling with appropriate relationships (one-to-many, many-to-many), data validation, and indexes where needed. Evaluate if the schema is normalized appropriately and handles edge cases. Look for efficient query patterns and proper use of Mongoose schemas/methods. Review data integrity measures and validation logic.",
      "levels": {
        "Excellent": "Excellent database schema design with proper relationships, data validation, and efficient queries. Successfully integrates MongoDB/MySQL with Mongoose/ORM. Implements data integrity and handles edge cases.",
        "Good": "Good database structure with functional CRUD operations. Minor inefficiencies in schema design or query optimization. Most data operations work correctly.",
        "Fair": "Basic database connection with simple operations. Schema lacks proper relationships or validation. Some CRUD operations may be incomplete or inefficient.",
        "Poor": "Poor or missing database integration. Schema is poorly designed, queries fail frequently, or no meaningful data persistence exists."
      }
    },
    {
      "id": "criterion_5",
      "title": "Authentication & Authorization",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "hybrid",
      "unit_test_weight": 0.8,
      "gpt_weight": 0.2,
      "test_files": [
        "tests/backend/auth.test.js",
        "tests/backend/protected-routes.test.js",
        "tests/backend/token-management.test.js"
      ],
      "files_to_analyze": [
        "grading-folder/backend/middleware/auth.js",
        "grading-folder/backend/controllers/authController.js",
        "grading-folder/backend/routes/auth.js"
      ],
      "gpt_instructions": "Review authentication implementation quality and security. Check that passwords are properly hashed (not plain text), JWT tokens are implemented correctly, and protected routes are secured. Assess role-based access control if applicable. Look for secure session management and proper token storage practices. Note any security best practices followed or security vulnerabilities present.",
      "levels": {
        "Excellent": "Implements secure authentication system with proper password hashing (bcrypt), JWT tokens, protected routes, and role-based access control where appropriate. Sessions are managed securely.",
        "Good": "Functional authentication with password hashing and basic route protection. Minor security gaps or incomplete session management.",
        "Fair": "Basic authentication exists but with security concerns. May lack proper password hashing, token management, or route protection.",
        "Poor": "Authentication is absent, broken, or fundamentally insecure (storing plain text passwords, no route protection, etc.)."
      }
    },
    {
      "id": "criterion_6",
      "title": "Front-End/Back-End Integration",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "hybrid",
      "unit_test_weight": 0.9,
      "gpt_weight": 0.1,
      "test_files": [
        "tests/integration/api-calls.test.js",
        "tests/integration/data-flow.test.js",
        "tests/integration/error-handling.test.js"
      ],
      "files_to_analyze": [
        "grading-folder/frontend/services/**/*.js",
        "grading-folder/frontend/api/**/*.js",
        "grading-folder/frontend/utils/api.js"
      ],
      "gpt_instructions": "Evaluate the quality of API integration code. Check for proper error handling in API calls, appropriate loading states, and proper HTTP method usage. Look for organized API service layers vs. scattered fetch calls. Assess error handling patterns and user feedback mechanisms.",
      "levels": {
        "Excellent": "Seamless communication between client and server using Axios/Fetch with proper error handling, loading states, and data synchronization. Demonstrates understanding of async data flow and HTTP methods.",
        "Good": "Good integration with functional data flow. Minor issues in error handling, loading states, or response processing.",
        "Fair": "Basic integration working but with noticeable issues. Limited error handling, inconsistent data updates, or poor user feedback during operations.",
        "Poor": "Poor or broken integration. API calls fail frequently, data doesn't sync properly, or fundamental communication issues exist."
      }
    },
    {
      "id": "criterion_7",
      "title": "UI/UX Design & Responsiveness",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "gpt_semantic",
      "unit_test_weight": 0,
      "gpt_weight": 1.0,
      "test_files": [],
      "files_to_analyze": [
        "grading-folder/frontend/components/**/*.tsx",
        "grading-folder/frontend/components/**/*.jsx",
        "grading-folder/frontend/styles/**/*.css",
        "grading-folder/frontend/app/globals.css"
      ],
      "gpt_instructions": "Assess overall UI/UX quality and design consistency. Evaluate visual appeal, modern design principles, color scheme consistency, typography choices, and spacing. Check for evidence of responsive design implementation (Tailwind classes, CSS media queries, flexbox/grid usage). Review component styling for consistency and reusability. Look for intuitive navigation patterns and user-friendly interfaces. Note if the design appears polished and professional or basic/unrefined.",
      "levels": {
        "Excellent": "Exceptional user interface with modern design principles, consistent styling (CSS/Tailwind/styled-components), intuitive navigation, and fully responsive across devices. Demonstrates attention to user experience.",
        "Good": "Good UI design with responsive layouts and consistent styling. Minor inconsistencies in design or responsiveness on some screen sizes.",
        "Fair": "Basic functional interface but lacks polish. Limited responsiveness, inconsistent styling, or poor user experience in some areas.",
        "Poor": "Poor visual design, non-responsive layouts, or interface is difficult to use. Demonstrates minimal application of CSS/styling knowledge."
      }
    },
    {
      "id": "criterion_8",
      "title": "Code Quality & Organization",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "gpt_semantic",
      "unit_test_weight": 0,
      "gpt_weight": 1.0,
      "test_files": [],
      "files_to_analyze": [
        "grading-folder/frontend/**/*.tsx",
        "grading-folder/frontend/**/*.jsx",
        "grading-folder/frontend/**/*.js",
        "grading-folder/backend/**/*.js"
      ],
      "gpt_instructions": "Conduct a comprehensive code quality review. Evaluate naming conventions (variables, functions, components), file organization and structure, code reusability, and DRY principles. Look for code duplication, magic numbers, and code smells. Assess comment quality and code documentation. Check for consistent coding style, proper indentation, and readable code. Note if functions are appropriately sized and have single responsibilities. Identify examples of particularly good or poor code quality.",
      "levels": {
        "Excellent": "Excellent code structure with meaningful naming conventions, proper file organization, reusable components/functions, minimal code duplication, and comprehensive comments. Follows best practices throughout.",
        "Good": "Good code organization with clear structure. Minor issues in naming, some code duplication, or inconsistent patterns. Generally follows best practices.",
        "Fair": "Basic code organization but with structural issues. Inconsistent naming, significant code duplication, poor file structure, or limited comments.",
        "Poor": "Poor code quality with disorganized files, unclear naming, excessive duplication, or spaghetti code. Demonstrates lack of understanding of clean code principles."
      }
    },
    {
      "id": "criterion_9",
      "title": "TypeScript Implementation (if applicable)",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "hybrid",
      "unit_test_weight": 0.5,
      "gpt_weight": 0.5,
      "test_files": [
        "tests/typescript/type-checking.test.js",
        "tests/typescript/compilation.test.js"
      ],
      "files_to_analyze": [
        "grading-folder/frontend/**/*.tsx",
        "grading-folder/frontend/**/*.ts",
        "grading-folder/backend/**/*.ts"
      ],
      "gpt_instructions": "If the project uses TypeScript, evaluate the quality of type implementation. Check for proper type annotations on functions, components, and variables. Look for custom interfaces and types. Assess use of 'any' type (should be minimal). Review type guards, generics, and advanced TypeScript features if present. If the project does NOT use TypeScript, mark this criterion as N/A or evaluate based on JavaScript code quality instead.",
      "special_note": "If project does not use TypeScript (.tsx/.ts files), this criterion should be marked as N/A or points redistributed",
      "levels": {
        "Excellent": "Comprehensive TypeScript usage with proper type annotations, interfaces, type guards, and generics. Demonstrates strong understanding of static typing benefits. No 'any' types except where absolutely necessary.",
        "Good": "Good TypeScript implementation with proper typing on most components and functions. Minor use of 'any' types or missing type definitions in some areas.",
        "Fair": "Basic TypeScript usage but relies heavily on 'any' types or lacks proper interfaces. Type safety benefits are not fully realized.",
        "Poor": "Minimal TypeScript implementation or project uses JavaScript without demonstrating TypeScript learning."
      }
    },
    {
      "id": "criterion_10",
      "title": "Git Version Control",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "unit_test",
      "unit_test_weight": 1.0,
      "gpt_weight": 0,
      "test_files": [
        "tests/git/commit-history.test.js"
      ],
      "files_to_analyze": [],
      "git_analysis": true,
      "gpt_instructions": "This criterion is evaluated through git command analysis.",
      "levels": {
        "Excellent": "Consistent, meaningful commit history throughout development process. Clear commit messages following conventions. Demonstrates understanding of branching, merging, and proper version control workflow.",
        "Good": "Regular commits with generally clear messages. Good version control practices with minor inconsistencies.",
        "Fair": "Infrequent commits or unclear commit messages. Version control used but demonstrates limited understanding of proper Git workflow.",
        "Poor": "Minimal commit history (few large commits), unclear messages, or no evidence of proper version control usage throughout development."
      }
    },
    {
      "id": "criterion_11",
      "title": "Testing & Debugging",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "hybrid",
      "unit_test_weight": 0.5,
      "gpt_weight": 0.5,
      "test_files": [
        "tests/student-tests/test-existence.test.js",
        "tests/student-tests/console-errors.test.js"
      ],
      "files_to_analyze": [
        "grading-folder/frontend/**/*.test.js",
        "grading-folder/frontend/**/*.spec.js",
        "grading-folder/backend/**/*.test.js",
        "grading-folder/backend/**/*.spec.js"
      ],
      "gpt_instructions": "Evaluate if the student has written their own tests. Check for test file existence, test quality, and coverage of critical functionality. Assess if tests are meaningful (not just placeholder tests). Review test organization and naming. Check if the application runs without console errors. Note the quality and comprehensiveness of their testing approach.",
      "levels": {
        "Excellent": "Implements unit tests (Jest) or E2E tests (Playwright) for critical functionality. Application is thoroughly tested with minimal bugs. Console is clean without errors.",
        "Good": "Application is well-tested manually with few bugs. May lack automated tests but demonstrates thorough debugging and quality assurance.",
        "Fair": "Basic testing performed but notable bugs remain. Console shows some errors. Limited evidence of systematic testing approach.",
        "Poor": "Application has significant bugs affecting core functionality. Minimal testing performed. Console shows multiple errors."
      }
    },
    {
      "id": "criterion_12",
      "title": "Advanced Features & Innovation",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "gpt_semantic",
      "unit_test_weight": 0,
      "gpt_weight": 1.0,
      "test_files": [],
      "files_to_analyze": [
        "grading-folder/frontend/**/*",
        "grading-folder/backend/**/*"
      ],
      "gpt_instructions": "Identify and evaluate advanced features beyond basic CRUD operations. Look for: real-time updates (WebSockets, Socket.io), file upload functionality, third-party API integrations, payment processing, email notifications, search functionality, data visualization, advanced state management, caching strategies, or other sophisticated features. Assess the complexity and implementation quality of these features. Consider if features add genuine value or are just 'feature bloat'.",
      "levels": {
        "Excellent": "Goes beyond basic requirements with advanced features like real-time updates (WebSockets), file uploads, third-party API integration, payment processing, email notifications, or other sophisticated functionality.",
        "Good": "Includes some advanced features beyond core requirements. Demonstrates initiative to learn and implement new concepts.",
        "Fair": "Meets basic requirements but includes minimal advanced features. Limited exploration beyond course material.",
        "Poor": "Only implements basic CRUD operations. No attempt to include advanced features or demonstrate independent learning."
      }
    },
    {
      "id": "criterion_13",
      "title": "Security Best Practices",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "hybrid",
      "unit_test_weight": 0.4,
      "gpt_weight": 0.6,
      "test_files": [
        "tests/security/env-variables.test.js",
        "tests/security/sql-injection.test.js",
        "tests/security/sensitive-data.test.js"
      ],
      "files_to_analyze": [
        "grading-folder/backend/**/*.js",
        "grading-folder/frontend/**/*.js"
      ],
      "gpt_instructions": "Conduct a security review of the codebase. Check for input validation and sanitization, protection against SQL/NoSQL injection, XSS protection measures, CORS configuration, proper use of environment variables for sensitive data, secure HTTP headers, and avoidance of sensitive data exposure in client-side code. Look for security packages usage (helmet, express-validator, etc.). Identify any security vulnerabilities or poor practices.",
      "levels": {
        "Excellent": "Demonstrates strong security awareness with input validation, SQL injection/NoSQL injection prevention, XSS protection, CORS configuration, environment variables for sensitive data, and secure HTTP headers.",
        "Good": "Good security practices with most vulnerabilities addressed. Minor gaps in validation or configuration.",
        "Fair": "Basic security measures but with notable vulnerabilities. May expose sensitive data, lack input validation, or have weak security configurations.",
        "Poor": "Poor security practices. Sensitive data exposed, no input validation, or demonstrates fundamental security misunderstanding."
      }
    },
    {
      "id": "criterion_14",
      "title": "Performance & Optimization",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "hybrid",
      "unit_test_weight": 0.5,
      "gpt_weight": 0.5,
      "test_files": [
        "tests/performance/load-time.test.js",
        "tests/performance/query-efficiency.test.js"
      ],
      "files_to_analyze": [
        "grading-folder/frontend/**/*",
        "grading-folder/backend/**/*"
      ],
      "gpt_instructions": "Evaluate performance optimization efforts. Look for: optimized images (Next.js Image component), efficient database queries (proper indexing, avoiding N+1 queries), lazy loading implementation, code splitting, memoization (useMemo, useCallback), efficient re-rendering patterns, and bundle size considerations. Check for unnecessary re-renders in React components. Assess if performance best practices are followed.",
      "levels": {
        "Excellent": "Application loads quickly with optimized images, efficient queries, lazy loading where appropriate, and minimal unnecessary re-renders. Demonstrates understanding of performance best practices.",
        "Good": "Good performance with minor optimization opportunities. Application runs smoothly with acceptable load times.",
        "Fair": "Noticeable performance issues such as slow load times, inefficient queries, or excessive re-renders. Limited optimization applied.",
        "Poor": "Poor performance with significant lag, inefficient database queries, or application feels sluggish. No evidence of performance consideration."
      }
    },
    {
      "id": "criterion_15",
      "title": "Documentation & README",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "gpt_semantic",
      "unit_test_weight": 0,
      "gpt_weight": 1.0,
      "test_files": [],
      "files_to_analyze": [
        "README.md",
        "grading-folder/README.md",
        "grading-folder/docs/**/*"
      ],
      "gpt_instructions": "Evaluate documentation quality and completeness. Check README for: clear project description, comprehensive setup instructions, environment variables template/list, technology stack explanation, features list, usage instructions, and screenshots or demo links. Assess code comments for helpfulness and clarity. Look for API documentation if applicable. Evaluate overall documentation professionalism and usefulness for someone trying to run/understand the project.",
      "levels": {
        "Excellent": "Comprehensive README with project description, setup instructions, environment variables template, tech stack explanation, features list, and screenshots/demo. Code includes helpful comments.",
        "Good": "Good README with clear setup instructions and project overview. Minor missing details or limited code documentation.",
        "Fair": "Basic README with minimal information. Setup instructions incomplete or unclear. Limited code documentation.",
        "Poor": "Missing or extremely limited README. No setup instructions or project documentation."
      }
    },
    {
      "id": "criterion_16",
      "title": "Deployment & Production Readiness",
      "max_points": 4,
      "weight": 1.0,
      "evaluation_method": "unit_test",
      "unit_test_weight": 1.0,
      "gpt_weight": 0,
      "test_files": [
        "tests/deployment/url-accessibility.test.js",
        "tests/deployment/functionality.test.js"
      ],
      "files_to_analyze": [],
      "deployment_url_file": "DEPLOYMENT_URL.txt",
      "gpt_instructions": "This criterion is evaluated by testing the deployed application URL.",
      "levels": {
        "Excellent": "Application is successfully deployed to production platform (Netlify, Vercel, Heroku, Render, etc.) with proper environment configuration. Live demo is fully functional and accessible.",
        "Good": "Application is deployed with minor configuration issues or limited production optimization. Live demo mostly functional.",
        "Fair": "Deployment attempted but with significant issues. Live demo may have broken features or deployment is incomplete.",
        "Poor": "Application not deployed or deployment is completely non-functional. No live demo available for testing."
      }
    }
  ],
  "scoring_guide": {
    "excellent": 4.0,
    "good": 3.0,
    "fair": 2.0,
    "poor": 1.0,
    "decimals_allowed": true,
    "decimal_explanation": "Scores can include decimals (e.g., 2.5, 3.7) when performance falls between two levels"
  },
  "grade_scale": {
    "A": {"min": 57.6, "max": 64},
    "A-": {"min": 54.4, "max": 57.5},
    "B+": {"min": 51.2, "max": 54.3},
    "B": {"min": 48, "max": 51.1},
    "B-": {"min": 44.8, "max": 47.9},
    "C+": {"min": 41.6, "max": 44.7},
    "C": {"min": 38.4, "max": 41.5},
    "C-": {"min": 35.2, "max": 38.3},
    "D": {"min": 32, "max": 35.1},
    "F": {"min": 0, "max": 31.9}
  }
}